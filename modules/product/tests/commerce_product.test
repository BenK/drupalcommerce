<?php
// $Id$

/**
 * @file
 * Unit tests for the commerce product module.
 */

/**
 * Test the product and product type CRUD.
 */
class CommerceProductCRUDTestCase extends DrupalWebTestCase {
  public static function getInfo() {
    return array(
      'name' => 'Commerce product CRUD',
      'description' => 'Tests the commerce product module',
      'group' => 'Drupal Commerce',
    );
  }

  function setUp() {
    parent::setUp('commerce_product');
  }

  /**
   * Ensure base product types have been created.
   */
  function testCommerceProductDefaultProducts() {
    $default_types = array(
      'product' => 'Product',
    );

    // Load the default content types
    $types_created = commerce_product_types();

    // Ensure each type exists
    foreach ($default_types as $type => $name) {
      $this->assertTrue(!empty($types_created[$type]), t('Product type %type has been created', array('%type' => $type)));
    }
  }

  /**
   * Test the product type crud
   */
  function testCommerceProductTypeCrud() {

    // Ensure commerce_product_type_new() returns a valid empty product type.
    $new_product_type = commerce_product_type_new();
    $this->assertNotNull($new_product_type->type, t('commerce_product_type_new() created the type element'));
    $this->assertNotNull($new_product_type->name, t('commerce_product_type_new() created the help element'));
    $this->assertNotNull($new_product_type->description, t('commerce_product_type_new() created the help element'));
    $this->assertNotNull($new_product_type->help, t('commerce_product_type_new() created the help element'));

    // Define values for testing.
    $type = $this->randomName(20);
    $name = $this->randomName(40);
    $description = $this->randomString(128);
    $help = $this->randomString(128);

    // Add the values to the new content type.
    $new_product_type->type = $type;
    $new_product_type->name = $name;
    $new_product_type->description = $description;
    $new_product_type->help = $help;
    $new_product_type->is_new = TRUE;

    // Ensure content_product_type_save() returns the proper value when inserting.
    $return = commerce_product_type_save($new_product_type);
    $this->assertEqual($return, SAVED_NEW, t('commerce_product_type_save() returned SAVED_NEW when saving a new product type'));

    // Load the newly saved content type.
    $saved_product_type = commerce_product_type_load($type);

    // Ensure the values that were saved match the values that we created.
    $this->assertTrue($saved_product_type, t('commerce_product_type_load() loaded the new product type'));
    $this->assertEqual($type, $saved_product_type->type, t('The new product type field was properly saved and loaded'));
    $this->assertEqual($name, $saved_product_type->name, t('The new product type name was properly saved and loaded'));
    $this->assertEqual($description, $saved_product_type->description, t('The new product description text was properly saved and loaded'));
    $this->assertEqual($help, $saved_product_type->help, t('The new product help text was properly saved and loaded'));

    // Alter the title, to ensure the update function works.
    $altered_name = $this->randomName(40);
    $saved_product_type->name = $altered_name;

    // Ensure content_product_type_save() returns the proper value when updating.
    $return = commerce_product_type_save($saved_product_type);
    $this->assertEqual($return, SAVED_UPDATED, t('commerce_product_type_save() returned SAVED_UPDATED when saving a new product type'), t('Comemrce product'));

    // Ensure the altered title was saved to the database, and loaded.
    $saved_product_type = commerce_product_type_load($type);
    $this->assertEqual($saved_product_type->name, $altered_name, t('commerce_product_type_save() successfully updated the product type name.'));
  }
 
  /**
   * Test the product crud
   */
  function testCommerceProductCrud() {
  
  }
}



/**
 * Test the rules and entity metadata integration.
 */
class CommerceProductRulesTestCase extends DrupalWebTestCase {
  
  public static function getInfo() {
    return array(
      'name' => 'Commerce product rules integration',
      'description' => 'Tests the commerce product rules integration',
      'group' => 'Drupal Commerce',
    );
  }

  function setUp() {
    parent::setUp('commerce_product', 'rules');
  }
  
  /**
   * Calculates the output of t() given an array of placeholders to replace.
   */
  static function t($text, $strings) {
    $placeholders = array();
    foreach ($strings as $string) {
      $placeholders['%' . $string] = drupal_placeholder(array('text' => $string));
    }
    return strtr($text, $placeholders);
  }
  
  /**
   * Tests rules CRUD actions for products.
   */
  function testRulesCRUD() {
    
    //TODO: test creation when metadata is there.
    /*
    $action = rules_action('entity_create', array(
      'type' => 'commerce_product',
      'param_type' => $type,
    ));
    $action->access();
    $action->execute();
    
    
    $text = RulesLog::logger()->render();
    $pos = strpos($text, self::t('Added the provided variable %entity_created of type %commerce_product', array('entity_created', 'commerce_product')));
    $pos = ($pos !== FALSE) ? strpos($text, self::t('Saved %entity_created of type %commerce_product.', array('entity_created', 'commerce_product')), $pos) : FALSE;
    $this->assertTrue($pos !== FALSE, 'Product has been created and saved.');
    */

    
    $product = commerce_product_new($this->product_type);
    commerce_product_save($product);
    debug('d');
    $rule = rule();
    $rule->action('entity_fetch', array('type' => 'commerce_product', 'id' => $product->product_id, 'entity_fetched:var' => 'product'));
    $rule->action('entity_save', array('data:select' => 'product', 'immediate' => TRUE));
    $rule->action('entity_delete', array('data:select' => 'product'));
    $rule->access();
    $rule->integrityCheck()->execute();
    $text = RulesLog::logger()->render();
    $pos = strpos($text, RulesTestCase::t('Evaluating the action %entity_fetch.', array('entity_fetch')));
    $pos = ($pos !== FALSE) ? strpos($text, self::t('Added the provided variable %commerce_product of type %commerce_product', array('commerce_product')), $pos) : FALSE;
    $pos = ($pos !== FALSE) ? strpos($text, self::t('Saved %commerce_product of type %commerce_product.', array('commerce_product')), $pos) : FALSE;
    $pos = ($pos !== FALSE) ? strpos($text, self::t('Evaluating the action %entity_delete.', array('entity_delete')), $pos) : FALSE;
    $this->assertTrue($pos !== FALSE, 'Product has been fetched, saved and deleted.');
    debug(RulesLog::logger()->render());
    
  }
  
  /**
   * Tests making use of product metadata.
   */
  function testProductPropertyInfo() {
    // Populate $values with all values that are setable. They will be set
    // with an metadata wrapper, so we also test setting that way.
    $values = array();
    foreach (entity_metadata_wrapper('commerce_product') as $name => $wrapper) {
      $info = $wrapper->info();
      if (!empty($info['setter callback'])) {
        $info += array('type' => 'text');
        $values[$name] = $this->createValue($info['type'], $info);
      }
    }
    $values['type'] = 'product';
    $product = entity_metadata_entity_create('commerce_product', $values)->value();
    $this->assertTrue($product, "Created a product and set all setable values.");
    
    $wrapper = entity_metadata_wrapper('commerce_product', $product);
    foreach ($wrapper as $key => $child) {
      $this->assertValue($wrapper, $key);
    }
  }
}


  
